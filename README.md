# 코테, 알고리즘 인터뷰를 어떻게 준비할 것인가

의식적인 훈련! 아무 생각 없이 문제만 많이 푸는 것은 시간 낭비이다.

문제 해결 능력을 기르는데 초점을 두고 의식적으로 훈련하자.

## 알고리즘 설계와 구현

우선 효율성을 제쳐두고 가장 빠르게 떠올릴 수 있는 단순한 방법을 생각한다. 생각의 과정을 말로 정리한다.

알고리즘 설계의 다섯 가지 접근법(출처: Cracking the Coding Interview)

1. 예증: 한 가지 예시를 붙잡고 이를 일반화 하는법
2. 패턴 매칭: 풀어야할 알고리즘이 어떤 문제와 유사한지 살피고 지금 문제에 적용할 알고리즘을 개발한다.
3. 단순화와 일반화: 자료형이나 데이터 양과 같은 제약 조건을 변경하여 문제를 단순화한 다음 해법을 찾고 이를 일반화한다.
4. 초기 사례로부터의 확장: 우선 n=1일 경우를 푼다. n=2일 경우를 푼다. n=3을 푼다. n-1을 알 경우 n에 대한 답을 찾을 수 있는 방법을 구한다.
5. 자료구조 브레인스토밍: 일련의 자료구조를 차례차례 적용해보고 해결되는지 본다.

의사코드를 작성하며 대략적인 시간 복잡도를 계산해본다.

시간 복잡도가 O(n^2) 이상인 경우 최적화할 수 있는 방법을 고민해본다.

의사 코드를 보며 어떤 부분에서 시간복잡도가 증가하는지 파악한다.

해당 부분을 어떻게 최적화할 수 있을지 고민한다.

오류가 없는지 테스트한다.

* 극단적인 경우: 0, 음수, null, 최댓값, 최솟값
* 엣지 케이스, 경계값에서 오류가 발생하지 않는지

의사 코드를 구현한다.

## 이론에 대한 공부

출처: http://theyearlyprophet.com/interviews-101-preparation.html

* 배열 조작 관련 알고리즘
    - 정렬 알고리즘: 학부 졸업생에게 퀵소트나 머지소트 구현해 보라는 문제 정도는 흔히 나온다. 구현은 물론이고, 이들의 공통점(둘다 분할 정복 알고리즘이다)과 차이점(퀵소트는 분할 과정이 복잡하고, 머지소트는 병합 과정이 복잡하다) 도 알아두면 좋다.
    - 이분 탐색 알고리즘: 벤틀리가 직업 프로그래머들에게 이분 탐색을 구현하게 시켰더니 90%는 제대로 못짜더라라는 일화는 유명하다. 이만큼 구현하기 까다로우니까 신경 써서 한번 구현해 보면 좋다. <생각하는 프로그래밍>에서 아주 잘 다루고 있다.
    - k번째 원소 선택 알고리즘: 퀵소트의 응용판인데 아주 유용하다. 원리를 이해해 두면 다른 문제 푸는 데도 여럿 응용 가능하다.
* 자료 구조
    - 스택, 큐
    - 해시: ~~에서 ~~를 빠르게 찾으려면 어떻게 할까요? 라는 질문의 절반 정도는 그냥 "해시 쓰면 안되나요?" 라고 대답할 수 있다.
    - 이진 트리: ~~에서 ~~보다 작은/큰 원소를 빠르게 찾으려면 어떻게 할까요? 라는 질문의 절반 정도는 그냥 "이진 트리 쓰면 안되나요?" 라고 대답할 수 있다.

해시나 이진 트리는 특성이나 시간 복잡도를 잘 공부해 두는 것이 좋다.

결론적으로...

* 대표적인 정렬 알고리즘은 바로바로 설명하고 코드 작성까지 할 수 있도록 숙달한다.
* 기본적이고 중요한 자료구조(스택, 큐, 해시 등)는 직접 구현해본다.

## 언어

내가 주로 사용하는 언어는 자바이지만, 코테에는 파이썬이 더 유리한 것 같다. 특히 문자열을 다루는 방식은 파이썬이 압도적으로 간단하다.

실제로 우테코 3기 코테를 볼때, 후반부 문제(문제 순서가 난이도 오름차순이었다) 중에 문자열 슬라이싱으로 거의 10분만에 푼 문제가 있었는데
아마 자바로 풀었으면 그 시간대에 절대 못 풀었을 것 같다.

코테 준비는 파이썬으로 하되, 파이썬에서만 가능한 방식(파이썬이기 때문에 쉽게 해결할 수 있었던)으로 푼 문제는 자바로 다시 구현해보자. 

# 이 레포의 구성 및 커밋 규칙

## 구성

* problems
* recap
* dataStructure/src
    - linear
    - graph
    - tree
    - hash

## 커밋 규칙

tag
* solved: 제한 시간안에 풀었으며 recap할 필요 없음
* hard: 제한 시간안에 풀지 못함

알고리즘 이론, 자료구조: theory: <이름>
문제: problem:<문제출처-번호-이름> <tag>
recap: recap:<문제출처-번호-이름>, 추가적으로 왜 풀지 못했는지 분석

