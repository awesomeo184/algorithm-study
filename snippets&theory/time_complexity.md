# 수행 시간 분석

수행 시간은 입력의 크기 n 그리고 입력의 형태와 관계있다.
기본 연산의 수행 시간을 분석한다.

## Worst-Case Running Time

크기가 n인 가능한 모든 입력에 대하여 실행되는 기본 연산의 최대 수행 시간

- W(n)으로 나타낸다.
- 최악의 입력이 무엇인지는 비교적 쉽게 추정 가능하므로 수행 시간 측정이 용이함.
- 수행 시간의 upper bound를 제공(아무리 오래 걸려도 W(n) 이하임을 보장할 수 있다.)
- 최악의 상황을 고려하는 것이 중요한 경우(ex. 실시간 항공 제어)에 유용하다.
- 단점: 최악의 상황은 비교적 적게 일어난다. 즉 정확한 알고리즘 실행 시간이라고 할 수 없음.

## Average-Case Running Time

크기가 n인 가능한 모든 입력에 대하여 실행되는 기본 연산의 수의 평균

- A(n)으로 나타낸다.
- 단점: 최악의 경우와 비교해 분석이 어렵다.

## Best-Case Running Time

크기가 n인 가능한 모든 입력에 대하여 실행되는 기본 연산의 최소값

B(n)으로 나타낸다.

## Running Time

수행 시간은 T(n)으로 표기한다.

T(n) = 실행되는 기본 연산의 개수 <= W(n)

# 점근적(Asymptotic) 분석

n이 매우 커질 때 수행 시간을 분석

수행 시간 대신 시간 복잡도(time complexity)라는 용어를 사용한다.

입력 크기 n에 대한 수행 시간의 점근적 증가율을 함수로 표현

## Big-O Notation

`O(f(n))`: 어떤 실수 c와 음이 아닌 정수 k에 대해 n >= k 인 모든 n에 대해
g(n) >= c*f(n)을 만족하는 함수 g(n)의 집합

쉽게 말하면 아무리 많이 증가해봐야 f(n)의 비율로 증가하는 함수들의 집합을 의미한다.

`g(n) ∈ O(f(n))` 혹은 `g(n)이 O(f(n))`라고 말하기도 함
⇒ 함수 g는 함수 f 보다 빠르게 증가하지 않는다(상수 비율의 차이는 무시).

## Big-Omega Notation

`Ω(f(n))`: 어떤 실수 c와 음이 아닌 정수 k에 대해 n >= k 인 모든 n에 대해
g(n) <= c*f(n)을 만족하는 함수 g(n)의 집합

쉽게 말하면 적어도 f(n)의 비율로 증가하는 함수들의 집합을 의미한다.

`g(n) ∈ Ω(f(n))` 혹은 `g(n)이 Ω(f(n))`라고 말하기도 함
⇒ 함수 g는 함수 f 보다 느리게 증가하지 않는다.

## Big-Theta Notation

Θ(f(n)) : n >= k인 모든 정수 n에 대하여 c1 * f(n) ≤ g(n) ≤ c2 * f(n)을 만
족하는 세 수 k, c1, c2가 존재하면 g(n) ∈ Θ(f(n))

정확하게 f(n)의 비율로 증가하는 함수들의 집합

Formal definition
Θ(f(n)) = O(f(n)) ∩ Ω(f(n))


`g(n) ∈ Θ(f(n))` 혹은 g(n) = Θ(f(n))이라고 말하기도 함
⇒ g는 f 와 같은 정도로 증가한다


